# Error Handling and Custom Exceptions Module â€“ Implementation Plan

## Domain & Purpose

Defines all domain-specific exceptions, error codes, and centralizes error handling logic for API, scraping, and data layers. Ensures consistent error reporting and robust handling across the project.

Due to the complexity originally presented in this document, we have revised the approach to be much smaller in scope.  Updated version of the document is here: [docs\06 exceptionsImplementation.v2.md]

## Directory Structure

```directory
src/d3_item_salvager/exceptions/
    __init__.py
    api.py           # API-specific exceptions
    data.py          # Data/model exceptions
    scraping.py      # Scraper exceptions
    handlers.py      # Centralized error handling logic
```

## Tools & Libraries

- Python built-in exceptions
- FastAPI exception handlers

## Design Patterns

- Custom exception classes with context/error codes
- Centralized error handler functions
- API error middleware for consistent JSON error responses

## Key Classes & Functions

- `ApiError`, `DataError`, `ScrapingError`: Custom exception classes (see examples below)
- `handle_api_error(request: Request, exc: ApiError) -> JSONResponse`: FastAPI exception handler (see handler template below)
- `handle_scraping_error(exc: ScrapingError, context: dict | None = None) -> None`: Scraper error handler for non-API errors

### Handler Function Signatures & Registration

**FastAPI Exception Handler Example:**

```python
from fastapi import Request
from fastapi.responses import JSONResponse
from d3_item_salvager.exceptions.api import ApiError

def handle_api_error(request: Request, exc: ApiError) -> JSONResponse:
    http_code = map_error_code_to_http(exc.code)
    logger.error(f"API error: {exc.message}", exc_info=True, extra={"context": exc.context})
    return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})

# Register with FastAPI
app.add_exception_handler(ApiError, handle_api_error)
```

**Scraping Error Handler Example:**

```python
def handle_scraping_error(exc: ScrapingError, context: dict | None = None) -> None:
    http_code = map_error_code_to_http(exc.code)
    logger.error(f"Scraping error: {exc.message}", exc_info=True, extra={"context": exc.context})
    # Additional handling logic as needed
    return {"error": {"message": exc.message, "code": exc.code, "context": exc.context, "http_code": http_code}}
```

## Implementation Details

- Use narrow exception catching; never catch `Exception` broadly
- Document all exceptions with context and error codes
- Ensure all API errors return consistent JSON responses
- Log all errors with stack traces
- Centralized error handlers should be registered with FastAPI and used in scraping/data layers

### Standardized Error Codes & Context

All custom exceptions should include:

#### Error Code Conventions

- 1001: Data validation failed
- 1002: Data not found
- 1003: Data integrity error
- 2001: Scraping failed
- 2002: Parsing error
- 2003: Network error

Document the meaning of each code in code comments and in the shared error code reference section below.

## Shared Error Code Reference

This section documents all standardized error codes used in custom exceptions. Update this table whenever new codes are added or changed.

| Code  | Meaning                  | Error Type      |
|-------|--------------------------|-----------------|
| 1001  | Data validation failed   | DataError       |
| 1002  | Data not found           | DataError       |
| 1003  | Data integrity error     | DataError       |
| 2001  | Scraping failed          | ScrapingError   |
| 2002  | Parsing error            | ScrapingError   |
| 2003  | Network error            | ScrapingError   |
| 400   | Bad request              | ApiError        |
| 404   | Not found                | ApiError        |
| 422   | Unprocessable entity     | ApiError        |
| 500   | Internal server error    | All             |

Refer to this table when assigning codes to new exceptions or handlers.

**Example DataError:**

```python
raise DataError("Data validation failed", code=1001, context={"field": "item_id"})
```

**Example ScrapingError:**

```python
raise ScrapingError("Parsing error", code=2002, context={"url": "https://example.com/guide"})
```

### Context Dict Structure for Custom Exceptions

All custom exceptions (`ApiError`, `DataError`, `ScrapingError`) should include a `context` dict for extra details. The context dict is optional but recommended for debugging and error reporting.

**Recommended Context Fields Table:**

| Error Type      | Field Name      | Description                                      |
|-----------------|-----------------|--------------------------------------------------|
| API Error       | field           | Field or parameter causing the error              |
|                 | user_id         | User involved (if applicable)                     |
|                 | request_data    | Relevant request payload                          |
|                 | stack_trace     | Stack trace info (for debugging)                  |
| Data Error      | field           | Data field or model attribute                     |
|                 | model           | Model or table name                               |
|                 | operation       | Operation being performed (e.g., insert, update)  |
|                 | details         | Any additional info                               |
|                 | stack_trace     | Stack trace info (for debugging)                  |
| Scraping Error  | url             | URL being scraped                                 |
|                 | step            | Scraping step (e.g., fetch, parse)                |
|                 | details         | Any additional info                               |
|                 | stack_trace     | Stack trace info (for debugging)                  |

Refer to this table when constructing context dicts for new exceptions.

**Example context dict:**

```python
context = {
    "field": "username",
    "user_id": 123,
    "request_data": {"username": "bad!"},
    "stack_trace": "..."
}
```

**Standard Error Response Example:**

```json
{
  "error": {
    "message": "Invalid request",
    "code": 400,
    "context": {"field": "username"}
  }
}
```

### Logging Strategy

**Logging Strategy:**

This project uses Loguru for unified, structured logging across all modules. Loguru supports structured logging and extra fields out of the box, making it the recommended default. If you must use the standard library logger, follow the configuration guidance below.

**Loguru Example:**

```python
from loguru import logger
logger.error(f"API error: {exc.message} (code={exc.code})", extra={"context": exc.context})
```

**Standard Library Logger Example:**

```python
import logging
logger = logging.getLogger(__name__)
logger.error(f"API error: {exc.message} (code={exc.code})", exc_info=True, extra={"context": exc.context})
```

**Standard Logger Configuration:**
To support structured logging with extra fields, configure the logger with a custom formatter:

```python
import logging
class ContextFilter(logging.Filter):
    def filter(self, record):
        context = getattr(record, 'context', None)
        if context:
            record.msg += f" | context={context}"
        return True

logger = logging.getLogger(__name__)
logger.addFilter(ContextFilter())
```

If your logger does not support `extra`, log context as part of the message:

```python
logger.error(f"[TYPE] error: {exc.message} (code={exc.code}) | context={exc.context}", exc_info=True)
```

Replace `[TYPE]` with `API`, `Data`, or `Scraping` as appropriate.

**Example for DataError:**

```python
logger.error(f"Data error: {exc.message} (code={exc.code})", extra={"context": exc.context})
```

**Example for ScrapingError:**

```python
logger.error(f"Scraping error: {exc.message} (code={exc.code})", extra={"context": exc.context})
```

## Testing & Extensibility

- Test correct attributes and inheritance
- Test handler returns correct JSON response and logs error
- Use provided template (see below)

### Extending Error Handling and Registration

To add a new exception type or handler:

1. **Create the exception class** in the appropriate module (e.g., `src/d3_item_salvager/exceptions/yourtype.py`). Inherit from `BaseError` and follow the template.
2. **Implement the handler function** for FastAPI (or other frameworks), following the logging and response conventions shown above.
3. **Register the handler** in your FastAPI app initialization. This should be done in your main application setup, typically in `src/d3_item_salvager/web/main.py` or wherever your FastAPI app is instantiated.

**FastAPI Handler Registration Example:**

```python
from fastapi import FastAPI
from d3_item_salvager.exceptions import ApiError, DataError, ScrapingError
from d3_item_salvager.exceptions.handlers import handle_api_error, handle_data_error, handle_scraping_error

app = FastAPI()

# Register custom exception handlers
app.add_exception_handler(ApiError, handle_api_error)
app.add_exception_handler(DataError, handle_data_error)
app.add_exception_handler(ScrapingError, handle_scraping_error)
```

**Integration Steps:**

1. Import your exception classes and handler functions.
2. Register each handler with `app.add_exception_handler` immediately after app instantiation.
3. Ensure all routes and background tasks use these exceptions for error signaling.
4. Test handler registration by triggering exceptions in test endpoints or unit tests.
5. **Add unit tests** for the new exception and handler, verifying correct attributes, logging, and response.
6. **Update documentation** in this file and in code docstrings, including error code conventions and context structure.
7. **If needed, update the shared error code reference** to document new codes and their meanings.

**Example:**

### Documentation Update Checklist for Error Handling Changes

Whenever you make changes to error handling (new exception, handler, codes, context, etc.), ensure you:

1. Update this implementation plan file (`docs/06 exceptionsImplementation.md`) with:
   - New exception class and handler details
   - Error code conventions and context structure
   - Registration and integration steps
2. Add or update Google-style docstrings in all new/modified exception classes and handler functions
3. Update the shared error code reference (if maintained separately)
4. Add or update usage examples in documentation and code comments
5. Review and update any related API or developer documentation
6. Ensure all changes are reflected in unit/integration test docstrings
7. Update integration and E2E tests if error handling changes affect user-facing behavior (e.g., API responses, error propagation)
8. Update README and any external/public API documentation if error handling changes affect public interfaces or usage patterns

**Unit Test Example:**

```python
def test_api_error_attributes():
    err = ApiError("Bad", code=400, context={"field": "username"})
    assert err.message == "Bad"
    assert err.code == 400
    assert err.context["field"] == "username"
```

**Unit Test Example for DataError Handler:**

```python
def test_handle_data_error_returns_json_response():
    from fastapi.testclient import TestClient
    from fastapi import FastAPI, Request
    app = FastAPI()

    @app.exception_handler(DataError)
    def handle_data_error(request: Request, exc: DataError):
        http_code = map_error_code_to_http(exc.code)
        return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})

    @app.get("/data-error")
    def trigger_data_error():
        raise DataError("Data validation failed", code=1001, context={"field": "item_id"})

    client = TestClient(app)
    response = client.get("/data-error")
    assert response.status_code == map_error_code_to_http(1001)  # Should be 422
    assert response.json()["error"]["code"] == 1001  # Custom error code in body
    assert response.json()["error"]["message"] == "Data validation failed"
    assert response.json()["error"]["context"]["field"] == "item_id"
```

**Unit Test Example for ScrapingError Handler:**

```python
def test_handle_scraping_error_returns_json_response():
    from fastapi.testclient import TestClient
    from fastapi import FastAPI, Request
    app = FastAPI()

    @app.exception_handler(ScrapingError)
    def handle_scraping_error(request: Request, exc: ScrapingError):
        http_code = map_error_code_to_http(exc.code)
        return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})

    @app.get("/scraping-error")
    def trigger_scraping_error():
        raise ScrapingError("Parsing error", code=2002, context={"url": "https://example.com/guide"})

    client = TestClient(app)
    response = client.get("/scraping-error")
    assert response.status_code == map_error_code_to_http(2002)  # Should be 422
    assert response.json()["error"]["code"] == 2002  # Custom error code in body
    assert response.json()["error"]["message"] == "Parsing error"
    assert response.json()["error"]["context"]["url"] == "https://example.com/guide"
```

## Exception Class Templates & Examples

### Base Exception Template

```python
class BaseError(Exception):
    """Base exception for all domain errors."""
    def __init__(self, message: str, code: int = 500, context: dict | None = None):
        super().__init__(message)
        self.message = message
        self.code = code
        self.context = context or {}

    def __str__(self) -> str:
        return f"{self.__class__.__name__}(message={self.message!r}, code={self.code}, context={self.context})"

**Example Usage:**

```python
err = DataError("Data validation failed", code=1001, context={"field": "item_id"})
print(err.message)  # "Data validation failed"
print(err.code)     # 1001
print(err.context)  # {"field": "item_id"}
print(str(err))     # DataError(message='Data validation failed', code=1001, context={'field': 'item_id'})
```

**Inheritance Rule:**

All custom exceptions for API, data/model, and scraping errors must inherit from `BaseError`. This ensures consistent attributes (`message`, `code`, `context`) and enables centralized error handling and logging. Only inherit directly from `Exception` for truly generic or framework-specific errors that do not require custom attributes or centralized handling.
**Note:**

- If you need a new domain-specific error, always subclass `BaseError`.
- If you must use a third-party or framework exception, document the reason and ensure it does not interfere with centralized error handling.

### ApiError Example

```python
class ApiError(BaseError):
    """Custom exception for API errors."""
    pass
```

### DataError Example

```python
class DataError(BaseError):
    """Custom exception for data/model errors."""
    pass
```

### ScrapingError Example

```python
class ScrapingError(BaseError):
    """Custom exception for scraping errors."""
    pass
```

## Handler Implementations for Custom Exceptions

**Handler Return Code Guidance:**
Only valid HTTP status codes should be used for the `status_code` argument in JSONResponse. If your custom error code is not a valid HTTP status code, map it to the appropriate HTTP code (e.g., 400, 404, 422, 500) and include the custom code in the response body for client-side handling.

**Comprehensive Error Code to HTTP Status Mapping:**

| Custom Code | Meaning                  | HTTP Status | Reasoning                  |
|------------|--------------------------|-------------|----------------------------|
| 1001       | Data validation failed   | 422         | Unprocessable Entity       |
| 1002       | Data not found           | 404         | Not Found                  |
| 1003       | Data integrity error     | 500         | Internal Server Error      |
| 2001       | Scraping failed          | 500         | Internal Server Error      |
| 2002       | Parsing error            | 422         | Unprocessable Entity       |
| 2003       | Network error            | 502         | Bad Gateway               |
| 400        | Bad request              | 400         | Bad Request                |
| 404        | Not found                | 404         | Not Found                  |
| 422        | Unprocessable entity     | 422         | Unprocessable Entity       |
| 500        | Internal server error    | 500         | Internal Server Error      |

**Mapping Function Example:**

```python
def map_error_code_to_http(code: int) -> int:
    mapping = {
        1001: 422,  # Data validation failed
        1002: 404,  # Data not found
        1003: 500,  # Data integrity error
        2001: 500,  # Scraping failed
        2002: 422,  # Parsing error
        2003: 502,  # Network error
        400: 400,   # Bad request
        404: 404,   # Not found
        422: 422,   # Unprocessable entity
        500: 500,   # Internal server error
    }
    return mapping.get(code, 500)  # Default to 500 if unknown
```

**Usage Example:**

```python
@app.exception_handler(DataError)
def handle_data_error(request: Request, exc: DataError):
    http_code = map_error_code_to_http(exc.code)
    return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
```

**Example mapping function:**

```python
def map_error_code_to_http(code: int) -> int:
    if code in {1001, 1003, 2002}:  # Validation, integrity, parsing errors
        return 422  # Unprocessable Entity
    if code == 1002:  # Data not found
        return 404
    if code in {2001, 2003}:  # Scraping/network errors
        return 500
    if code in {400, 404, 422, 500}:
        return code
    return 500  # Default fallback
```

**ApiError Handler:**

```python
@app.exception_handler(ApiError)
def handle_api_error(request: Request, exc: ApiError) -> JSONResponse:
    logger.error(f"API error: {exc.message}", exc_info=True, extra={"context": exc.context})
    http_code = map_error_code_to_http(exc.code)
    return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
```

**DataError Handler:**

```python
@app.exception_handler(DataError)
def handle_data_error(request: Request, exc: DataError) -> JSONResponse:
    logger.error(f"Data error: {exc.message}", exc_info=True, extra={"context": exc.context})
    http_code = map_error_code_to_http(exc.code)
    return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
```

**ScrapingError Handler:**

```python
@app.exception_handler(ScrapingError)
def handle_scraping_error(request: Request, exc: ScrapingError) -> JSONResponse:
    logger.error(f"Scraping error: {exc.message}", exc_info=True, extra={"context": exc.context})
    http_code = map_error_code_to_http(exc.code)
    return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
```

**Non-API Scraping Error Handler (for use outside FastAPI):**

**Usage Guidance:**
Use the non-API scraping error handler in scripts, background jobs, or CLI tools where FastAPI is not available. Log the error and decide whether to propagate, retry, or exit based on the error type and context. You may also return a structured result or error object for downstream processing.

**Example:**

```python
def handle_scraping_error(exc: ScrapingError, context: dict | None = None) -> dict:
    logger.error(f"Scraping error: {exc.message}", exc_info=True, extra={"context": exc.context})
    # Optionally propagate, retry, or return a structured error
    return {"error": {"message": exc.message, "code": exc.code, "context": exc.context}}
```

## Middleware vs Handler Distinction

- **Exception Handler:** Handles specific exceptions and returns a response (e.g., FastAPI's `add_exception_handler`).
- **Middleware:** Intercepts all requests/responses, can catch unhandled exceptions globally.

**Handler Example:**

```python
@app.exception_handler(ApiError)
def handle_api_error(request: Request, exc: ApiError) -> JSONResponse:
    logger.error(f"API error: {exc.message}", exc_info=True)
    return JSONResponse(status_code=exc.code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
```

**Middleware Example:**

**Complete Middleware Example:**

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from d3_item_salvager.exceptions import BaseError

app = FastAPI()

@app.middleware("http")
async def error_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except BaseError as exc:
        # Custom domain error: log and return structured response
        logger.error(f"Custom error: {exc.message} (code={exc.code}) | context={exc.context}", exc_info=True)
        http_code = map_error_code_to_http(exc.code)
        return JSONResponse(status_code=http_code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
    except Exception as exc:
        # Generic error: log and return fallback response
        logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
        return JSONResponse(status_code=500, content={"error": {"message": "Internal server error", "code": 500, "context": {}}})
```

### Middleware Integration with Custom Errors

Middleware should distinguish between custom errors (inheriting from `BaseError`) and generic exceptions. This allows for more informative error responses and logging.

**Example:**

```python
@app.middleware("http")
async def error_middleware(request: Request, call_next):
    try:
        return await call_next(request)
    except BaseError as exc:
        # Custom error: log and return structured response
        logger.error(f"Custom error: {exc.message} (code={exc.code})", exc_info=True, extra={"context": exc.context})
        return JSONResponse(status_code=exc.code, content={"error": {"message": exc.message, "code": exc.code, "context": exc.context}})
    except Exception as exc:
        # Generic error: log and return generic response
        logger.error("Unhandled error", exc_info=True)
        return JSONResponse(status_code=500, content={"error": {"message": str(exc), "code": 500}})
```

This pattern ensures custom errors are handled with full context, while generic errors receive a fallback response.

## Centralized Error Handling Registration

```python
app.add_exception_handler(ApiError, handle_api_error)
app.add_exception_handler(DataError, handle_data_error)
app.add_exception_handler(ScrapingError, handle_scraping_error)
```

Place registration code in your FastAPI app initialization.

**Best Practice:**

Place all exception handler registrations in your FastAPI app's main entry point (e.g., `src/d3_item_salvager/web/main.py`) or a dedicated startup module. This ensures all error handling is centralized and easy to maintain.

**Example:**

```python
# src/d3_item_salvager/web/main.py
from fastapi import FastAPI
from d3_item_salvager.exceptions.api import ApiError, handle_api_error
from d3_item_salvager.exceptions.data import DataError, handle_data_error
from d3_item_salvager.exceptions.scraping import ScrapingError, handle_scraping_error

app = FastAPI()
app.add_exception_handler(ApiError, handle_api_error)
app.add_exception_handler(DataError, handle_data_error)
app.add_exception_handler(ScrapingError, handle_scraping_error)
```

## Example Usage

```python
from d3_item_salvager.exceptions.api import ApiError
raise ApiError("Invalid request", code=400, context={"field": "username"})
```

## Summary

This module provides a robust, consistent error handling and exception system for the project. All errors must be reported with context and codes, and handled centrally for maintainability and debugging. The plan now includes handler signatures, error code/context standards, logging, testing, templates for new exceptions, middleware/handler distinction, and registration details for a complete and actionable roadmap.
